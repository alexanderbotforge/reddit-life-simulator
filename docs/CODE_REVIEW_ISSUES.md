# Анализ проблем проекта Reddit Life Simulator

**Версия документа:** 1.0.2  
**Дата:** 2025-02-01  
**Описание:** Выявленные проблемы в коде, тестах, документации и соответствии ТЗ. Пункты с пометкой **[ИСПРАВЛЕНО]** устранены в 1.0.1.

---

## 1. Критичные и логические проблемы

### 1.1 `last_session_at` нигде не обновляется **[ИСПРАВЛЕНО]**

В `AccountState` есть поле `last_session_at`, но в `rls.py` после сессии оно не устанавливается. По ТЗ «история сессий» и «восстановление состояния» предполагают знание времени последней сессии.

**Рекомендация:** В `rls.py` после успешной сессии присваивать `state.last_session_at = datetime.now(timezone.utc).isoformat()` (или дату в нужном формате) перед `save_account_state`. *Сделано в 1.0.1.*

---

### 1.2 Лимит upvote «за сессию» реализован неверно **[ИСПРАВЛЕНО]**

В `behavior.py` функция `max_upvotes_for_session(state)` использует **глобальный** счётчик `state.upvotes_count`:

```python
return min(UPVOTES_PER_SESSION_MAX, max(0, UPVOTES_PER_SESSION_MAX - (state.upvotes_count % 10)))
```

По ТЗ лимит — **«не более одного–двух upvote за сессию»**, то есть на одну сессию, а не от общего числа upvote. Текущая формула даёт «1–2 в зависимости от накопленного числа» и не отражает лимит именно в рамках текущей сессии.

**Рекомендация:** Лимит за сессию задавать внутри сессии (например, в `browser.run_session` или передавать в неё `max_upvotes=UPVOTES_PER_SESSION_MAX`). `max_upvotes_for_session` может просто возвращать `UPVOTES_PER_SESSION_MAX` или случайное 1/2 в рамках лимита, без привязки к `state.upvotes_count`. *В 1.0.1: возвращается random.randint(1, UPVOTES_PER_SESSION_MAX).*

---

### 1.3 Коллизия имён при нормализации `account_id` **[ИСПРАВЛЕНО]**

В `state.py` путь к файлу состояния строится так:

```python
safe_id = "".join(c if c.isalnum() or c in "-_" else "_" for c in account_id)
```

Пробелы и другие символы заменяются на `_`. В результате `"acc 1"` и `"acc_1"` дают один и тот же файл `acc_1_state.json` — разным аккаунтам может соответствовать один файл состояния.

**Рекомендация:** Либо не нормализовать `account_id` (если он контролируется и не содержит недопустимых символов), либо использовать однозначное кодирование (например, хэш или явное правило), чтобы разные `account_id` не совпадали. *В 1.0.1: хэш-суффикс в state_path, обратная совместимость со старым форматом.*

---

## 2. Надёжность и обработка ошибок

### 2.1 Нет обработки ошибок при чтении/записи состояния и конфигов **[ИСПРАВЛЕНО]**

- `state.load_account_state` — при повреждённом JSON или ошибке чтения файла возникнет необработанное исключение.
- `state.save_account_state` / `save_summary` — при нехватке места на диске или отсутствии прав запись упадёт без обработки.
- `config.load_account_config` — при битом JSON исключение перехватывается в `load_all_account_configs`, но при одиночном вызове — нет.

**Рекомендация:** В `load_account_state` и `load_summary` при `JSONDecodeError`/`OSError` логировать ошибку и возвращать пустое состояние/пустой список. Для записи — по возможности логировать и пробрасывать или возвращать признак ошибки, чтобы вызывающий код мог отреагировать. *В 1.0.1: try/except в load_account_state и load_summary, логирование, возврат пустого состояния/списка. В 1.0.3: try/except в save_account_state и save_summary (логирование и проброс); обработка ошибок в load_account_config (логирование и проброс).*

---

### 2.2 Нет проверки типа `extra` в состоянии **[ИСПРАВЛЕНО]**

В `state.AccountState.from_dict` используется `extra=data.get("extra", {})`. Если в JSON у `extra` тип не dict (например, список или null), в объекте окажется значение неверного типа, а при следующем `to_dict()`/`asdict()` возможны ошибки сериализации или несовместимость при загрузке.

**Рекомендация:** Нормализовать: `extra = data.get("extra") if isinstance(data.get("extra"), dict) else {}`. *В 1.0.1: функция extra_normalized(), вызов в from_dict.*

---

## 3. Качество кода и соглашения

### 3.1 Неиспользуемые импорты **[ИСПРАВЛЕНО]**

- **rls.py:** импортируется `load_all_account_configs` и `build_daily_report_entry`, но не используются (достаточно `get_accounts_queue` и `append_to_summary`).
- **config.py:** импортируются `os` и `PROJECT_VERSION`, не используются.

**Рекомендация:** Удалить неиспользуемые импорты (уменьшит шум при линтинге и поддержке). *В 1.0.1: удалены.*

---

### 3.2 Два источника версии **[ДОКУМЕНТИРОВАНО]**

Версия задаётся и в `constants.PROJECT_VERSION`, и в файле `VERSION`. Они могут расходиться при обновлении только в одном месте.

**Рекомендация:** Либо читать версию из `VERSION` при старте (или из одного модуля), либо явно синхронизировать оба места в процессе релиза (и описать это в документации/правилах). *В 1.0.3: в docs/README.md добавлен раздел «Версионирование» — при релизе обновлять оба места.*

---

## 4. Соответствие ТЗ и документации

### 4.1 Порядок аккаунтов в очереди жизни **[ИСПРАВЛЕНО]**

`get_accounts_queue` возвращает порядок, заданный `glob("*.json")` — он от файловой системы и нестабилен. В ТЗ порядок не задан, но для воспроизводимости и отладки фиксированный порядок (например, по `account_id`) может быть полезен.

**Рекомендация:** Опционально сортировать список по `account_id` перед возвратом. *В 1.0.1: get_accounts_queue сортирует по account_id.*

---

### 4.2 Ежедневный отчёт «в конце дня» **[ИСПРАВЛЕНО]**

По ТЗ «в конце каждого дня» фиксируется статус и «ежедневно» формируется Telegram-отчёт. Сейчас запись в сводку и статус пишутся при каждом цикле очереди жизни (при каждом запуске `rls.py`), а не по расписанию «раз в день».

**Рекомендация:** Либо явно зафиксировать в документации, что «день» = «один цикл очереди» / «один запуск», либо ввести планировщик (cron/systemd timer) и отдельную команду/режим «ежедневный отчёт», вызываемую раз в сутки. *В 1.0.1: отчёт отправляется в 23:58 по расписанию — `python rls.py --send-daily-report` (cron: 58 23 * * *).*

---

### 4.3 Отсутствие валидации конфигурации **[ИСПРАВЛЕНО]**

Не проверяются:

- формат прокси (URL или host:port);
- допустимость таймзоны (например, через `zoneinfo`);
- непустой `account_id` в конфиге (сейчас отфильтровывается в очереди, но конфиг с пустым id всё равно загружается).

**Рекомендация:** Добавить валидацию при загрузке конфига (хотя бы обязательные поля и тип полей) и при невалидном конфиге логировать/пропускать или падать с понятным сообщением. *В 1.0.1: strip для account_id, timezone, language, region; значения по умолчанию.*

---

## 5. Тесты

### 5.1 Случайность в поведенческой модели

`should_skip_session_today` и `max_session_duration_seconds` используют `random` без фиксации seed. Тесты, завязанные на это поведение, будут нестабильными.

**Рекомендация:** В тестах либо мокать `random`, либо вызывать функции много раз и проверять инварианты (например, что результат в допустимых границах), либо задавать `random.seed()` в тесте для воспроизводимости.

---

### 5.2 Нет тестов на обработку ошибок

Нет проверок на:

- повреждённый JSON в файле состояния/сводки;
- отсутствующий или нечитаемый файл конфига;
- невалидные значения в JSON (отрицательные числа, неверный тип `extra`).

**Рекомендация:** Добавить тесты с «битыми» файлами и невалидными данными и ожидаемым поведением (пустое состояние, пропуск конфига, логирование и т.д.).

---

## 6. Резюме

| Категория              | Количество |
|------------------------|------------|
| Критичные/логические   | 3          |
| Надёжность/ошибки      | 2          |
| Качество кода          | 2          |
| ТЗ/документация        | 3          |
| Тесты                  | 2          |

Приоритетно имеет смысл исправить: обновление `last_session_at`, корректный лимит upvote за сессию, коллизию имён в `state_path`, обработку ошибок при чтении/записи состояния и конфигов, нормализацию `extra` в `from_dict`, удаление неиспользуемых импортов. Остальное можно планировать по важности для текущего этапа разработки.
